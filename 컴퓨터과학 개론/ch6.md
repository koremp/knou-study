# 알고리즘 - 2

## 정렬 알고리즘

### 퀵 정렬

pivot, partition
* 분할정복 방법을 적용
* 최선 O(nlogn)
* 최악 O(n^2)

### 합병 정렬

* 분할정복 방법을 적용
  * 분할
  * 정복
  * 결합
* 최선, 최악, 평균 -> O(nlogn)

## 순차 탐색, 이진 탐색

### 순차 탐색

* O(N)
* 모든 리스트에 적용 가능
  * 데이터 비정렬시 적합

### 이진 탐색
* 분할 정복 이용하는 알고리즘
* O(logn)
* 데이터가 이미 정렬된 경우 적용 가능

## 이진 탐색 트리

* 이진 트리
* 각 노드의 왼쪽 서브트리의 모든 키값은 그 노드의 키값보다 작다
* 각 노드의 오른쪽 서브트리의 모든 키값은 그 노드의 키값보다 크다

### 탐색 연산

원하는 키 값을 갖는 원소를 찾는다

### 삽입 연산

* 탐색 성공시 삽입 없이 종료
* 탐색 실패시 실패 지점에서 자식 노드를 생성하여 추가

### 삭제 연산

후속자(계승자, successor) 노드
* 어떤 노드의 바로 다음 키값을 갖는 노드

삭제되는 노드의 자식 노드의 개수에 따라 구분해서 처리
* 없는 경우
* 1개인 경우
* 2개인 경우

키값의 비교 횟수에 비례 -> 이진 트리의 높이가 h라면 `O(h)`

평균수행시간 O(logn)

최악수행시간 O(n)

## 해싱

탐색 키값을 기반으로 데이터의 저장 위치를 직접 계산
* 상수 시간 내 데이터를 탐색, 삽입, 삭제 가능

### 해시 함수

키값을 해시 테이블 주소로 변환하는 함수
바람직한 해시 함수는
* 계산 용이
* 테이블의 각 슬롯에 균등하게 사상시킬 수 있어야한다(충돌 최소)

#### 제산 잔여법

`h(K) = K mod M`
K: 키값 M: 해시 테이블의 크기

#### 중간 제곱법

키값을 제곱한 결과에서 중간한 크기의 자릿수를 취하는 방법

#### 폴딩법

자리수를 반으로 나눠 AND/OR/XOR 연산 등을 함

#### 기수 변환법

N진법 M진법으로 변화

#### 자릿수 추출법

### 충돌 해결 방법

* 충돌
  * h(x) = h(y)
* 해결 방법
  * 연쇄법
    * chaining, linked list resolution
    * 동일한 주소로 사상된 데이터를 연결 리스트를 사용해 저장
  * 개방 주소법
    * open addressing
    * 정해진 방법에 따라 데이터를 저장할 빈 공간을 찾는 방법
    * 종류
      * 선형 탐사
      * 이차형 탐사
      * 이중 해싱

#### 연쇄법

#### 선형 탐사

* 가장 간단한 방법 -> 최악의 충돌 해결방법
* 1차 클러스터링
  * 데이터들이 연속된 위치를 점유하여 클러스터를 형성하고, 클러스터가 점점 커지게 됨 
  * 평균 탐색 시간의 증가를 초래
  
#### 2차형 탐사

* 2차적인 관계를 갖는 함수를 사용
* 2차 클러스터링
  * 2개의 키의 초기 위치가 동일시 전체 탐사순서가 동일

#### 이중 해싱

* 선형 탐사와 이차형 탐사의 문제 해결
* 두 번째 이후의 탐사 위치를 결정하는 다른 해시 함수 사용
  * 주 해시 함수와 독립적인 해시 함수를 사용하는 것이 중요